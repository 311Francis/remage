#include "MGManagerMessenger.hh"

#include <fstream>

#include "globals.hh"
#include "G4UIdirectory.hh"
#include "G4UIcmdWithAString.hh"
#include "G4UIcmdWithAnInteger.hh"
#include "G4UIcmdWithoutParameter.hh"
#include "Randomize.hh"

#include "MGManager.hh"
#include "MGManagementRunAction.hh"
#include "MGLog.hh"

MGManagerMessenger::MGManagerMessenger(MGManager*) {

  fDirectory = new G4UIdirectory("/MG/manager/");
  fDirectory->SetGuidance("Management controls.");

  fMGLogCmd = new G4UIcmdWithAString("/MG/manager/mglog", this);
  fMGLogCmd->SetGuidance("Set severity of logs to report to stdout.");
  fMGLogCmd->SetGuidance("Options, in ascending order of severity, are:");
  fMGLogCmd->SetGuidance("debug: Displays all logs ");
  fMGLogCmd->SetGuidance("detail: All logs, except debugging(default)");
  fMGLogCmd->SetGuidance("summary: All logs, except debugging and trace");
  fMGLogCmd->SetGuidance("warning: All logs, except trace, debugging and routine:");
  fMGLogCmd->SetGuidance("error: Only error and fatal logs.");
  fMGLogCmd->SetGuidance("fatal: Only fatal logs.");
  fMGLogCmd->SetCandidates("debug detail summary warning wrror fatal");

  fHEPRandomSeedCmd = new G4UIcmdWithAnInteger("/MG/manager/heprandomseed", this);
  fHEPRandomSeedCmd->SetGuidance("Sets random number generator seed.");

  fUseInternalSeedCmd = new G4UIcmdWithAnInteger("/MG/manager/useInternalSeed", this);
  fUseInternalSeedCmd->SetGuidance("Sets random number generator seed using internal seed table.");
  fUseInternalSeedCmd->SetGuidance("Provide the index of the seed you would like to use (0-429)");
  fUseInternalSeedCmd->SetParameterName("index", false);
  fUseInternalSeedCmd->SetRange("index>=0 && index<430");

  fSeedWithDevRandomCmd = new G4UIcmdWithoutParameter("/MG/manager/seedWithDevRandom", this);
  fSeedWithDevRandomCmd->SetGuidance("Seed random number generator with a \"truly\" random number");
  fSeedWithDevRandomCmd->SetGuidance("generated by a read from /dev/random");

  fUseRandomEngineCmd = new G4UIcmdWithAString("/MG/manager/useRandomEngine", this);
  fUseRandomEngineCmd->SetGuidance("Sets type of random engine to use.");
  fUseRandomEngineCmd->SetCandidates("JamesRandom RanLux MTwist");
}

MGManagerMessenger::~MGManagerMessenger() {
  delete fDirectory;
  delete fMGLogCmd;
  delete fUseRandomEngineCmd;
  delete fHEPRandomSeedCmd;
  delete fUseInternalSeedCmd;
  delete fSeedWithDevRandomCmd;
}

void MGManagerMessenger::SetNewValue(G4UIcommand* cmd, G4String new_values) {

  if (cmd == fMGLogCmd) {

    if      (new_values == "debug"  ) MGLog::SetLogLevelScreen(MGLog::debug);
    else if (new_values == "detail" ) MGLog::SetLogLevelScreen(MGLog::detail);
    else if (new_values == "summary") MGLog::SetLogLevelScreen(MGLog::summary);
    else if (new_values == "warning") MGLog::SetLogLevelScreen(MGLog::warning);
    else if (new_values == "error"  ) MGLog::SetLogLevelScreen(MGLog::error);
    else if (new_values == "fatal"  ) MGLog::SetLogLevelScreen(MGLog::fatal);
    else MGLog::OutError("Unknown option.");
  }
  else if (cmd == fHEPRandomSeedCmd) {

    G4long seed = std::stol(new_values);

    if (seed >= std::numeric_limits<long>::max()) {
      MGLog::OutError("Seed " + new_values + " is too large. Largest possible seed is " +
                      std::to_string(std::numeric_limits<long>::max()) + ". Setting seed to 0.");
      CLHEP::HepRandom::setTheSeed(0);
    }
    else CLHEP::HepRandom::setTheSeed(seed);
    MGLog::OutSummary("CLHEP::HepRandom seed set to: " + G4String(seed));
    MGManager::GetMGManager()->GetMGRunAction()->SetControlledRandomization();
  }
  else if (cmd == fUseInternalSeedCmd) {

    auto index = fUseInternalSeedCmd->GetNewIntValue(new_values);

    long seeds[2];
    int table_index = index/2;
    CLHEP::HepRandom::getTheTableSeeds(seeds, table_index);

    int array_index = index % 2;
    CLHEP::HepRandom::setTheSeed(seeds[array_index]);
    MGLog::OutSummary("CLHEP::HepRandom seed set to: " + std::to_string(seeds[array_index]));
    MGManager::GetMGManager()->GetMGRunAction()->SetControlledRandomization();
  }
  else if (cmd == fSeedWithDevRandomCmd) {

    std::ifstream devrandom("/dev/random");
    if (devrandom.bad()) {
      MGLog::OutWarning("Couldn't open /dev/random. Setting seed to 0.");
      CLHEP::HepRandom::setTheSeed(0);
    }
    else {
      MGLog::OutDebug("Reading a seed from /dev/random...");
      long seed;
      devrandom.read((char*)(&seed), sizeof(long));

      // Negative seeds give nasty sequences for some engines. For example,
      // CLHEP's JamesRandom.cc contains a specific check for this. Might
      // as well make all seeds positive; randomness is not affected (one
      // bit of randomness goes unused).
      if (seed < 0) seed = -seed;

      CLHEP::HepRandom::setTheSeed(seed);
      MGLog::OutSummary("CLHEP::HepRandom seed set to: " + G4String(seed));
      MGManager::GetMGManager()->GetMGRunAction()->SetControlledRandomization();
    }
    devrandom.close();
  }
  else if (cmd == fUseRandomEngineCmd) {

    if (new_values == "JamesRandom") {
      CLHEP::HepRandom::setTheEngine(new CLHEP::HepJamesRandom);
      MGLog::OutSummary("Using James engine.");
    }
    else if (new_values == "RanLux") {
      CLHEP::HepRandom::setTheEngine(new CLHEP::RanluxEngine);
      MGLog::OutSummary("Using RanLux engine.");
    }
    else if (new_values == "MTwist") {
      CLHEP::HepRandom::setTheEngine(new CLHEP::MTwistEngine);
      MGLog::OutSummary("Using MTwist engine.");
    }
    else {
      CLHEP::HepRandom::setTheEngine(new CLHEP::HepJamesRandom);
      MGLog::OutError(new_values + " engine unknown, setting default engine.");
      MGLog::OutSummary("Using James engine.");
    }
  }
}

// vim: tabstop=2 shiftwidth=2 expandtab
